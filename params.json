{
  "name": "EEG-Blinks",
  "tagline": "BLINKER: Automated blink detector for EEG",
  "body": "# Introduction to the BLINKER pipeline\r\nBLINKER and associated tools are an automated pipeline for detecting eye blinks in EEG and calculating various properties of these blinks. BLINKER takes as input an arbitrary number of signals, which can include ordinary EEG channels, EOG channels and independent components (IC), determines which signals have acceptable blinks and determining the optimal signal for determining blinks. BLINKER also has facilities for merging blinks calculating from different source signals and for plotting individual blinks to facilitate manual evaluation and synchronization of EEG with video and eye tracking. BLINKER is designed to be run in a completely automated way. \r\n\r\nThe major sections of this document are:\r\n* <a name=\"Introduction\">Introduction</a> (requirements, citing, installation)\r\n* [Running as an EEGLAB plug-in](#Plugin)\r\n* [Running as a script](#Script)\r\n* Quick start (Simple examples of running BLINKER)\r\n* Algorithm (steps, meaning of parameters for each step)\r\n* Description of BLINKER structures (blinks, blinkFits, blinkProperties, blinkStatistics)\r\n\r\n\r\n### Requirements\r\nThe BLINKER pipeline relies on the MATLAB Signal Processing toolbox, the MATLAB Statistics toolbox and EEGLAB, a freely-available MATLAB toolbox for processing EEG. EEGLAB is available from  [http://scn.ucsd.edu/eeglab](http://scn.ucsd.edu/eeglab). Various high-level BLINKER wrapper functions assume that the EEG data is provided as an EEGLAB EEG structure and that channel locations are provided in the EEG.chanlocs structure. However, low-level processing functions work directly\r\non signals.\r\n\r\n### Citing the BLINKER\r\nBLINKER is freely available under the GNU General Public License. \r\nPlease cite the following publication if using:  \r\n> Kleifges K, Bigdely-Shamlo N, Kerick S, and Robbins KA  \r\n> BLINKER: Large-scale automated analysis of ocular indices extracted from EEG  \r\n>  \r\n\r\n### Installation\r\nThe BLINKER pipeline can be run in two ways --- as a standalone toolbox or as an EEGLAB plugin. To run in standalone mode, simply download the BLINKER code, found in the EEG-Blinks github repository, and add the `blinker` directory and all of its subdirectories to the MATLAB path.\r\n\r\n## <a name=\"Plugin\">BLINKER as an EEGLAB plugin</a>\r\nYou can install BLINKER as an EEGLAB plugin by unzipping the BlinkerVxx directory into the plugins directory of your EEGLAB installation. \r\n\r\n## Running the BLINKER pipeline from EEGLAB\r\nLoad an EEG dataset to be processed using the `Load dataset` submenu under the `File` menu of EEGLAB. The BLINKER pipeline \r\ncan be found under the EEGLAB Tools submenu:  \r\n![BLINKER from EEGLAB](https://raw.githubusercontent.com/VisLab/EEG-Blinks/gh-pages/images/EEGLAB_Menu.png)  \r\n\r\n![BLINKER menu](https://raw.githubusercontent.com/VisLab/EEG-Blinks/gh-pages/images/BLINKER_Plugin.png)  \r\n![BLINKER menu](./images/BLINKER_Plugin.png) \r\n\r\n![BLINKER menu](https://vislab.github.io/EEG-Blinks/images/BLINKER_Plugin.png)  \r\n\r\n[Code linke](https://github.com/Vislab/EEG-Blinks/\r\n![BLINKER menu](https://github.com/VisLab/EEG-Blinks/tree/gh-pages/images/BLINKER_Plugin.png)  \r\n\r\n## <a name=\"Script\">Running BLINKER as a script in batch processing mode</a>\r\nWhile it is possible to run BLINKER as a plugin from EEGLAB, BLINKER is meant to be run in batch processing mode to analyze large collections of EEG. While it is possible to run BLINKER using the low-level functions, the easiest way to run BLINKER is to put your EEG dataset into an EEGLAB EEG structure.\r\n\r\n**Example**  \r\nRun BLINKER outside of EEGLAB but bring up a GUI to set parameters:\r\n\r\n> `[EEG, com, blinks, blinkFits, blinkProperties, blinkStatistics, params] = pop_blinker(EEG);`  \r\n\r\n**Example**  \r\nRun BLINKER without manual intervention, using all of the default parameters:\r\n\r\n> `[EEG, com, blinks, blinkFits, blinkProperties, blinkStatistics,  params] = pop_blinker(EEG, struct());  \r\n\r\n**Example**  \r\nThe previous example uses all of the default values, including defaults for metadata such as the `subjectID`. Usually you will want to override the defaults. When you are going to override defaults it is good to start with a complete `params` structure with all of the default values filled in:  \r\n\r\n> `params = checkBlinkerDefaults(struct(), getBlinkerDefaults(EEG));` \r\n\r\n\r\n**Example**  \r\nThe following example starts with a default `params` structure and then overrides some of the values related to controlling the output and to dataset metadata:  \r\n\r\n> `params = checkBlinkerDefaults(struct(), getBlinkerDefaults(EEG));`  \r\n> `params.subjectID = blinkFiles(k).subjectID;`  \r\n> `params.experiment = blinkFiles(k).experiment;`  \r\n> `params.uniqueName = blinkFiles(k).uniqueName;`  \r\n> `params.task = blinkFiles(k).task;`  \r\n> `params.fileName = blinkFiles(k).fileName;`  \r\n> `params.startDate = blinkFiles(k).startDate;`  \r\n> `params.startTime = blinkFiles(k).startTime;`  \r\n> `params.blinkerSaveFile = [blinkIndDir filesep  blinkFiles(k).blinkFileName '_' typeBlinks '.mat'];`  \r\n> `params.dumpBlinkerStructures = true;`  \r\n> `params.blinkerDumpDir = blinkIndDir;`  \r\n> `params.dumpBlinkImages = false;`  \r\n> `params.dumpBlinkPositions = false;`  \r\n> `params.keepSignals = false;`  \r\n> `params.showMaxDistribution = false;`  \r\n> `params.verbose = false;`  \r\n> `params.excludeLabels = {'a1', 'a2', 'vehicle position'}; \r\n> `[EEG, com, blinks, blinkFits, blinkProperties, blinkStatistics, params] = pop_blinker(EEG, params); \r\n\r\n\r\n*Example* \r\nRun BLINKER outside of EEGLAB but bring up a GUI to set parameters:\r\nTh\r\n\r\n# BLINKER Overview\r\nThis section discusses the algorithm and the setting of the various parameters.\r\n\r\n### Processing steps\r\n1. Extract potential blinks of each candidate signal.\r\n1. Calculate landmarks of potential blinks.\r\n1. Reject signals with low signal-to-noise (SNR) ratios.\r\n1. Calculate blink maximum amplitude distributions.\r\n1. Select the \"best\" candidate signal as the \"used\" signal.\r\n1. Calculate the blink properties and blink shapes for the \"used\" signal.\r\n1. Calculate the ocular indices for the \"used\" signal.\r\n\r\n## Extract potential blinks of each candidate signal\r\n\r\n\r\n## Detrend (high pass filtering)\r\nHigh pass filtering of some sort is needed in order for many of the algorithms, including line noise removal and\r\nreferencing to perform correctly. However, the exact cutoff may dramatically effect downstream algorithms. By default, \r\nPREP uses a 1 Hz cutoff, but only temporarily filters, so that the final signal is not high-pass filtered. This\r\nallows you to defer the final choice of high pass cutoff for downstream processing to later. \r\n\r\n### Calling sequence for removing trends\r\nThe `removeTrend` function takes two structures in and produces two output structures. The `signal` structure\r\nincludes a `.data` field and an `.srate` field. The `signal` structure is compatible with an EEGLAB EEG structure, but does not rely on any of the other EEGLAB fields. The `.data` field should be channels x frames. \r\n\r\nAs with all functions in the pipeline, the algorithm parameters are passed in a structure:  \r\n> `[signal, detrendOut] = removeTrend(signal)`  \r\n> `[signal, detrendOut] = removeTrend(signal, detrendIn)`  \r\n\r\nThe output structure contains all of the input structure fields plus additional fields including a string representation\r\nof the actual command used. Usually, the only field that a user might need to provide is `detrendChannels` if the `signal` structure contains extra channels that represent items other than EEG signals. \r\n\r\n**Example:**  \r\n> `detrendIn = struct('detrendChannels', [1:32, 40:60], 'detrendCutoff', 0.5);`  \r\n\r\n### Parameters for removing the trend\r\nThe following parameters appear as fields in the `detrendIn` structure:  \r\n\r\n**`detrendChannels`**  \r\n A row vector specifying the channel numbers of the channels to remove the trend from.  \r\nBy default, PREP uses all of the channels (`1:size(signal.data, 1)`). \r\nIf your signal has extraneous or unused channels, you should specify which channels to use.  \r\n\r\n\r\n**`srate`**\r\n A positive scalar giving the sampling rate of the signal in Hz. \r\nIf an EEG structure is passed to `getBlinkerDefaults`, the default value is `EEG.srate`. \r\nOtherwise, the default 1.\r\n \r\n**`stdThreshold`**    \r\n Number of robust standard deviations above the mean the signal for potential blinks.  \r\n[Scalar numeric positive (default is 1.5)]\r\n\r\n**`subjectID`**  \r\nString identifying the subject for the dataset. BLINKER uses this ID to combine short datasets from same session to get blink maxima distribution.  \r\n[String (default is 'Subject1_Task1_Experiment1_Rep1â€™)]\r\n     \r\n**`uniqueName`**  \r\nString uniquely identifying this dataset  \r\n[String (default is 'Unknown')]  \r\n\r\n**`experiment`** \r\n String identifying the experiment. \r\n[String (default is 'Experiment1')]\r\n\r\n**`task`**  \r\nName of task performed in this dataset  \r\n[String (default is 'Task1')]  \r\n\r\n**`startDate`**  \r\nString giving the start date of dataset in dd-mmm-yyyy format  \r\n[String (default is '01-Jan-2016')]\r\n\r\n**`startTime`**  \r\nString giving the start time in 24 hour hh:mm:ss format.    \r\n[String (default is '00:00:00')]\r\n   \r\n**`signalTypeIndicator`**  \r\nString specifying the type of signals from which to extract blinks.  \r\n[String with possible values are 'UseNumbers' or 'UseLabels' or 'UseICs' (default is 'UseNumbers')]\r\n\r\n**`signalNumbers`**  \r\nVector of numbers of the channel numbers to try as potential signals if signalTypeIndicator is 'UseNumbers'.  \r\n[Row vector of positive integers less than the number of channels (default 1:number of channels)]\r\n\r\n**`signalLabels`**  \r\nCell array of names of channels to try as potential signals if signalTypeIndicator is 'UseLabels'.  \r\n[Row cell array of channel labels (default: {'fp1', 'f1', 'fp2', 'fz', 'fpz', 'f3', 'f4', 'f2'})]\r\n\r\n**`excludeLabels`**  \r\nCell array of the names of signals to exclude from consideration.  \r\n[Row cell array of channel labels (default: {'exg5', 'exg6', 'exg7', 'exg8', 'vehicle position'})]\r\n\r\n**`dumpBlinkerStructures`**  \r\nLogical flag indicating whether to save all of the blinker structures in a file.  \r\n[Logical (default: true)]\r\n\r\n**`showMaxDistribution`**  \r\nLogical flag indicating whether to show a figure with a histogram of blink maxima.  \r\n[Logical (default: true)]\r\n\r\n**`dumpBlinkImages`**  \r\nLogical flag indicating whether to dump pictures of the individual blinks in a directory, indexed by an HTML file.  \r\n[Logical (default:true)]\r\n\r\n**`dumpBlinkPositions`**  \r\n\r\n    getRules(false, {'logical'}, {}, ...\r\nA logical flag indicating whether to dump a text file of the frame left zeros, and frames of blink maxima frames and times.'), ...\r\n\r\n**`fileName`**\r\nA string giving the full path name of the input EEG file.\r\n\r\n**`blinkerSaveFile`**\r\nName of file for saving the structures of blink locations and properties     getRules([pwd theName '_blinks.mat'], {'char'}, ...\r\n    {}, ...\r\n    'Name of file for saving the structures of blink locations and properties'), ...\r\n\r\n**`blinkerDumpDir`**\r\n    getRules([pwd filesep 'blinkDump'], {'char'}, {}, ...\r\n    'Name of directory in which to dump pictures of blinks.'), ...\r\n\r\n**`lowCutoffHz`**\r\n     getRules(1, {'numeric'}, {'scalar', 'nonnegative'}, ...\r\n       'Lower edge of bandpass filter'), ...\r\n\r\n**`highCutoffHz`**\r\n     getRules(20, {'numeric'}, {'scalar', 'positive'}, ...\r\n       'Upper edge of bandpass filter'),  ...\r\n**`minGoodBlinks`**\r\n     getRules(10, {'numeric'}, {'scalar', 'nonnegative'}, ...\r\n       'Minimum number of good blinks for signal to be a candidate'),  ...\r\n\r\n**`blinkAmpRange`**\r\n     getRules([3, 50], {'numeric'}, {'row', 'positive', 'numel', 2}, ...\r\n     'Range of blink amplitude ratios allowed for candidate signals'),  ...\r\n\r\n**`goodRatioThreshold`**\r\n     getRules(0.7, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...\r\n       'Minimum number of good blinks for signal to be a candidate'),  ...\r\n\r\n**`pAVRThreshold`**\r\n     getRules(3, {'numeric'}, {'scalar', 'positive'}, ...\r\n       'Minimum number of good blinks for signal to be a candidate'),  ...\r\n\r\n**`correlationThresholdTop`**\r\n     getRules(0.98, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...\r\n       'Correlation threshold for linear fits of best blinks'),  ...\r\n\r\n**`correlationThresholdBottom`**\r\n     getRules(0.90, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...\r\n       'Correlation threshold for linear fits of acceptable blinks'),  ...\r\n\r\n**`correlationThresholdMiddle`**\r\n     getRules(0.95, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...\r\n       'Correlation threshold middle range in displaying blink maxima'),  ...\r\n\r\n**`keepSignals`**\r\n     getRules(false, {'logical'}, {}, ...\r\n       ['Keep signals that pass the blink amplitude ratio test' ...\r\n       ' regardless of good ratio (for combination)']),  ...  \r\n\r\n**`shutAmpFraction`**\r\n      getRules(0.90, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...\r\n       'Fraction of maximum amplitude to reach for time shut'),  ...\r\n\r\n**`zThresholds`**\r\n     getRules([0.90, 2; 0.98, 5], {'numeric'}, {'positive', 'ncols', 2}, ...\r\n     'Rows contain correlation and max z-score threshold pairs for determining good blinks'), ...\r\n\r\n**`ICSimilarityThreshold`**\r\n     getRules(0.85, {'numeric'}, {'nonnegative', '<=', 1}, ...\r\n     'How similar and IC has to be to an eye IC to be a candidate'), ...\r\n\r\n**`ICFOMThreshold`**\r\nMean difference in IC scalp map amplitude of front versus rear hemispheres (used to select blink ICs)\r\n[Scalar numeric positive (default: 1)]\r\n\r\n**`numberMaxBins`**\r\nNumber of bins used to display histograms of blink maxima\r\n[Scalar numeric positive (default: 80)]      \r\n\r\n\r\n\r\n### Calling sequence for line noise removal\r\nThe `cleanLineNoise` function takes two structures in and produces two output structures. The `signal` structure\r\nincludes a `.data` field and an `.srate` field. The `signal` structure is compatible with an EEGLAB EEG structure, but does not rely on any of the other EEGLAB fields. The data field should be channels x frames. \r\n\r\nAs with all functions in the pipeline, the algorithm parameters are passed in a structure.  \r\n> `[signal, lineNoiseOut] = cleanLineNoise(signal)`  \r\n> `[signal, lineNoiseOut] = cleanLineNoise(signal, lineNoiseIn)`  \r\n\r\n#BLINKER structures\r\n![BLINKER menu]\r\n\r\n## The `blinks` structure\r\nThe `blinks` structure holds basic information about the dataset, the candidate signals and the positions of\r\nthe potential blinks in the candidate signals. \r\n\r\n**`fileName`**\r\n String with the full path name of the file from which the blinks were computed\r\n\r\n**`srate`**\r\n Sampling rate in Hz of the signal\r\n\r\n**`subjectID`**\r\n String identifying the subject from which the dataset was recorded. This field is used for display purposes and for combining datasets taken from a single subject in one session to improve estimates of blink maximum distribution.\r\n\r\n**`experiment`**\r\n String identifying the experiment or data collection that this dataset is part of.\r\n\r\n**`uniqueName`**\r\n String uniquely identifying this dataset within the context of the analysis. Usually this will be a combination of the experiment, subject, task, replicate, and other identifying information. This string is used for display purposes and for lookup of datasets within a combined analysis.\r\n\r\n**`task`**\r\n String identifying the task performed by the subject for this dataset.\r\n\r\n**`startTime`**\r\n Double value giving the days (to within) from xxx.\r\n\r\n**`signalData`**\r\n Structure with details of the candidate signals and potential blink positions.\r\n\r\n**`usedSignal`**\r\n Integer identifying the signal that is selected as the \"best\" signal for blinks. Usually this will be a channel number within the original dataset or the number of an IC within an independent component decomposition associated with the dataset. A negative value indicates that the results of the calculation were marginal and that the signal may not have captured the blinks reliability.\r\n\r\n**`status`**\r\n String indicated the status of the blink calculation. A value of \"success\" means that blinks were successfully computed, although the results may be marginal. A value of \"failed\" means that the algorithm could not extract blinks from any of the candidate signals provide.\r\n\r\n### The `signalData` substructure of `blinks`\r\n The `signalData` is a structure array containing information about candidate signals for the dataset. The individual fields are:\r\n\r\n**`signalType`**\r\n String indicating the type of signal this is. Usually the `signalType` will indicate how the initial candidate signals were specified and will have a value 'SignalNumbers', 'SignalLabels', `ICs'. \r\n\r\n**`signalNumber`**\r\nA unique integer identifier of the signal within the dataset as a whole (for example the channel number of the IC number.)\r\n[A positive integer.]\r\n\r\n**`signalLabel`**\r\nA unique identifier of the signal within the dataset as a whole (for example the channel label). BLINKER automatically creates labels for independent components: 'IC1', 'IC2', etc.\r\n[A string.]\r\n\r\n**`numberBlinks`**  \r\nThe number of potential blinks detected in this signal.\r\n[A nonnegative integer.]\r\n\r\n**`numberGoodBlinks`**  \r\nAn integer giving the number of \"good\" potential blinks detected in this signal. These blinks must have\r\nleft and right R^2 values at greater than `correlationThresholdBottom` (0.90 by default).\r\n[A nonnegative integer.]\r\n\r\n**`blinkAmpRatio`**  \r\nA positive value indicating the blink-amplitude ratio for this signal.\r\n\r\n**`cutoff`**  \r\nA positive value estimating the boundary between the blink maximum distributions of the \"good\" blink candidates and the other blink candidates. If this value is well away from the `bestMedian`, the dataset is likely to have  good separation between blinks and eye movements.\r\n\r\n**`bestMedian`**  \r\nA positive value giving the median blink maximum amplitude of the best candidate blinks. These blinks must have\r\nleft and right R^2 values at greater than `correlationThresholdTop` (0.98 by default).\r\n\r\n**`bestRobustStd`**  \r\nA positive number giving the 1.486 times the median absolute deviation from the median (mad) of the best candidate blinks. These blinks must have left and right R^2 values at greater than `correlationThresholdTop` (0.98 by default).\r\n\r\n**`goodRatio`**  \r\nA positive numeric value between 0 and 1 indicating the fraction of blinks whose maximum amplitude is within two robust standard deviations of the median of the best blinks that are \"good\" blinks. This is a measure of how badly eye movements confound the maximum amplitude distribution.\r\n\r\n**`signal`**  \r\nThe timeseries for this signal.\r\n\r\n**`blinkPositions`**  \r\nA 2 x n array with the frame numbers of the starts and ends of intervals defining the portion of the n potential blinks that exceeds the threshold. The blink maximum should be in this interval.\r\n\r\n## The **`blinkFits`** structure\r\nThe `blinkFits` structure array holds basic shape information for a set of potential blinks. In `extractBlinkProperties` function returns this structure for the potential blinks of the used signal that meet specific quality criteria. Values that are undefined, have value `NaN`. The fields are:\r\n\r\n**`number`**  \r\nThe number of the potential blink within the corresponding blinks structure.\r\n[A positive numeric value.]\r\n\r\n**`maxFrame`**  \r\nThe frame number of the first maximum amplitude of this blink.\r\n[A positive numeric value.]\r\n\r\n**`maxValue`**  \r\nA numeric value giving the maximum value of the blink.\r\n\r\n**`leftOuter`**  \r\nThe frame number of the left outer reach of the blink.\r\n[A positive numeric value.]\r\n\r\n**`rightOuter`**  \r\nThe frame number of the right outer reach of the blink.\r\n[A positive numeric value.]\r\n\r\n**`leftZero`**  \r\nThe frame number of the left zero crossing of the blink.\r\n[A positive numeric value.]\r\n\r\n**`rightZero`**  \r\nThe frame number of the right zero crossing of the blink.\r\n[A positive numeric value.]\r\n\r\n**`leftBase`**  \r\nThe frame number of the left local minimum of the blink.\r\n[A positive numeric value.]\r\n\r\n**`rightBase`**  \r\nThe frame number of the right local minimum of the blink.\r\n[A positive numeric value.]\r\n\r\n**`leftBaseHalfHeight`**  \r\nThe coordinate of the signal halfway (in height) between the blink maximum and the left base value.\r\n[A positive numeric value.]\r\n\r\n**`rightBaseHalfHeight`**  \r\nThe coordinate of the signal halfway (in height) between the blink maximum and the right base value.  \r\n[A positive numeric value.]\r\n\r\n**`leftZeroHalfHeight`**  \r\n\r\n**`rightZeroHalfHeight`**  \r\n\r\n**`leftRange`**  \r\n\r\n**`rightRange`**  \r\n\r\n**`leftSlope`**  \r\n[A negative value or NaN if the tent line doesn't exist.]\r\n\r\n**`rightSlope`**  \r\nSlope of the right blink tent line.\r\n[A negative value or NaN if the tent line doesn't exist.]\r\n\r\n**`averLeftVelocity`**  \r\n\r\n**`averRightVelocity`**  \r\n\r\n**`leftR2`**  \r\nThe correlation of the left tent line with the 80% blink upstroke. \r\n[A numeric value or NaN if the tent line doesn't exist.]\r\n\r\n**`rightR2`**  \r\nThe correlation of the right tent line with the 80% blink downstroke. \r\n[A numeric value or NaN if the tent line doesn't exist.]\r\n\r\n**`xIntersect`**  \r\nThe x-coordinate of the intersection of the left and right tent line with the x-axis.  \r\n[A numeric value or NaN if the tent line doesn't exist.]\r\n\r\n**`yIntersect`**  \r\nThe y-coordinate of the intersection of the left and right tent line with the x-axis.  \r\n[A numeric value or NaN if the tent line doesn't exist.]\r\n\r\n**`leftXIntercept`**  \r\nAn integer giving the frame number of the intersection of the left tent line with the x-axis (or NaN if the tent line doesn't exist).\r\n\r\n**`rightXIntercept`**   \r\nAn integer giving the frame number of the intersection of the right tent line with the x-axis (or NaN if the tent line doesn't exist).\r\n\r\n## The **`blinkProperties`** structure\r\nThe `blinkProperties` structure array holds basic ocular characteristics for a set of potential blinks. The `extractBlinkProperties` function returns this structure for the potential blinks of the used signal that meet specific quality criteria. Values that are undefined, have value `NaN`. The fields are:\r\n\r\n**`durationBase`**  \r\nLength of the blink in seconds calculated as the difference between `rightBase` and `leftBase`.\r\n\r\n**`durationZero`**  \r\n**`durationTent`**  \r\n**`durationHalfBase`**  \r\n**`durationHalfZero`**  \r\n**`interBlinkMaxAmp`**  \r\n**`interBlinkMaxVelBase`**  \r\n**`interBlinkMaxVelZero`**  \r\n**`negAmpVelRatioBase`**  \r\n**`posAmpVelRatioBase`**  \r\n**`negAmpVelRatioZero`**  \r\n**`posAmpVelRatioZero`**  \r\n**`negAmpVelRatioTent`**  \r\n**`posAmpVelRatioTent`**  \r\n**`'timeShutBase`**  \r\n**`'timeShutZero`**  \r\n**`timeShutTent`**  \r\n**`closingTimeZero`**  \r\n**`reopeningTimeZero`**  \r\n**`closingTimeTent`**  \r\n**`reopeningTimeTent`**  \r\n**`peakTimeBlink`**  \r\n**`peakTimeTent`**  \r\n**`peakMaxBlink`**  \r\n**`peakMaxTent`**  ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}